# ðŸ“˜ Find the Index of the First Occurrence in a String (strStr)

> **LeetCode â€“ Problem 28 | Java Implementation**

![Status](https://img.shields.io/badge/status-completed-brightgreen)
![Language](https://img.shields.io/badge/language-Java-orange)
![Difficulty](https://img.shields.io/badge/difficulty-easy-success)
![License](https://img.shields.io/badge/license-MIT-blue)

---

## âœ¨ Overview

This repository contains a **clean, beginner-friendly, and readable Java solution** for the classic string-search problem:

> Given two strings `haystack` and `needle`, return the index of the **first occurrence** of `needle` inside `haystack`.  
> If `needle` does not appear, return `-1`.

This solution uses the simple **sliding window technique**, which is easy to understand and implement.

---

## ðŸŽ¬ Animation / Visual Intuition

> _(Optional â€” Replace these GIFs with your own custom visuals later)_

<table>
  <tr>
    <td align="center">
      <img src="assets/strStr-scan.gif" alt="Sliding window animation" width="370" />
      <br/>
      <sub><b>Sliding window scanning each possible starting index</b></sub>
    </td>
    <td align="center">
      <img src="assets/strStr-match.gif" alt="Match found animation" width="370" />
      <br/>
      <sub><b>Needle matches at index i</b></sub>
    </td>
  </tr>
</table>

---

## ðŸ§  Intuition

- `needle` can only begin at positions from **0** to **n âˆ’ m**.
- At each position `i`, check a substring of length `m`.
- If that substring equals `needle â†’ return i`.
- If no match exists â†’ return `-1`.

This is a straightforward **brute-force substring matching** method.

---

## ðŸ›  Approach

1. Let:
   - `n = haystack.length()`
   - `m = needle.length()`

2. Traverse all valid starting positions:

```java
for (int i = 0; i <= n - m; i++) {
Extract substring of length m:

java
Copy code
haystack.substring(i, i + m)
Compare with needle

If equal â†’ return index

If loop ends â†’ return -1

â± Complexity
Time Complexity:
Substring comparison takes O(m)

Done for n âˆ’ m + 1 positions
âž¡ï¸ Worst Case: O(n Ã— m)

Space Complexity:
substring() creates a new string of size m
âž¡ï¸ Space: O(m)

âœ”ï¸ KMP algorithm reduces time to O(n + m)
âœ”ï¸ Manual character comparison avoids extra memory

ðŸ’» Java Implementation
java
Copy code
class Solution {
    public int strStr(String haystack, String needle) {
        int n = haystack.length();
        int m = needle.length();

        // Edge case: empty needle
        if (m == 0) return 0;

        // Slide a window of size m across haystack
        for (int i = 0; i <= n - m; i++) {
            if (haystack.substring(i, i + m).equals(needle)) {
                return i;  // match found
            }
        }

        return -1;  // no match
    }
}
â–¶ï¸ Run Locally
1. Clone the repository
sh
Copy code
git clone https://github.com/your-username/strStr-java.git
cd strStr-java
2. Compile
sh
Copy code
javac Solution.java
3. (Optional) Test with driver program
Create a Main.java:

java
Copy code
public class Main {
    public static void main(String[] args) {
        Solution s = new Solution();

        String haystack = "hello";
        String needle = "ll";

        int index = s.strStr(haystack, needle);

        System.out.println("First occurrence index: " + index);
    }
}
Compile & run:

sh
Copy code
javac Main.java
java Main
ðŸŒ± Future Improvements
ðŸš€ Implement KMP Algorithm for O(n + m) performance

âš¡ Avoid substring() to reduce extra memory usage

ðŸ§ª Add JUnit tests for robust testing

ðŸ§µ Try advanced algorithms like Rabinâ€“Karp or Boyerâ€“Moore

ðŸ“ Recommended Project Structure
powershell
Copy code
.
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ strStr-scan.gif
â”‚   â””â”€â”€ strStr-match.gif
â”œâ”€â”€ README.md
â”œâ”€â”€ Solution.java
â””â”€â”€ Main.java    # optional driver
â­ Support the Project
If this repository helped you:

ðŸ‘ Like it
â­ Star it
ðŸ´ Fork it
ðŸ’¬ Share your suggestions

Happy Coding! ðŸš€ðŸ’›
