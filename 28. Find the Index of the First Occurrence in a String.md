# ðŸ” Find the Index of the First Occurrence in a String (strStr)

> LeetCode â€“ Problem 28 | Java Implementation

![Status](https://img.shields.io/badge/status-completed-brightgreen)
![Language](https://img.shields.io/badge/language-Java-orange)
![Difficulty](https://img.shields.io/badge/difficulty-easy-success)
![License](https://img.shields.io/badge/license-MIT-blue)

---

## âœ¨ Overview

This repository contains a **clean and readable Java solution** for the classic string-matching problem:

> Given two strings `haystack` and `needle`, return the index of the **first occurrence** of `needle` in `haystack`.  
> If `needle` is not part of `haystack`, return `-1`.

---

## ðŸŽ¬ Animation / Visual Intuition

> _Replace the image/gif links below with your own later._

<table>
  <tr>
    <td align="center">
      <img src="assets/strStr-scan.gif" alt="Sliding window animation" width="380" />
      <br/>
      <sub><b>Sliding window over the haystack</b></sub>
    </td>
    <td align="center">
      <img src="assets/strStr-match.gif" alt="Match found animation" width="380" />
      <br/>
      <sub><b>Match found at index i</b></sub>
    </td>
  </tr>
</table>

The idea is simple:  
We move a **window of length `m` (length of `needle`)** across `haystack` and compare each substring with `needle`.

---

## ðŸ§  Intuition

- We know `needle` can only start at indices from `0` to `n - m` in `haystack`.
- At each index `i`, we:
  - Extract `haystack.substring(i, i + m)`
  - Compare it with `needle`
- The first index where they are equal is the answer.
- If no match is found, return `-1`.

This is a straightforward **brute-force substring matching** approach.

---

## ðŸ›  Approach

1. Let:
   - `n = haystack.length()`
   - `m = needle.length()`
2. Iterate `i` from `0` to `n - m` (inclusive).
3. For each `i`, take the substring:
   ```java
   haystack.substring(i, i + m)
